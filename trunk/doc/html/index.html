<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libspline: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6-NO -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>libspline Documentation</h1>
<p>
<h3 align="center">0.1.0</h3><h1>libspline</h1>
<p>
libspline is a C++ spline library with focus on speed and real-time applications integration.
<h2>Features</h2>
<p>libspline currently supports four types of splines; CatmullRom, Cardinal, KochanekBartels and Bezier. In the future Lagrange, B-Spline and NURBS will also
be available. This library is written for games and other real-time applications where speed has higher priority than precision.
<h2>License</h2>
libspline is released under the GNU LESSER GENERAL PUBLIC LICENSE (LGPL) license. See the LICENSE file for more information.
<h2>How to use</h2>
<h3>Build libspline</h3>
To use the library you first have to build it. Available projects are VS2003.NET, Dev-C++, Codeblocks and BeIDE. If you don't have any of these IDEs you
have to set up your own project. This should'nt be any problem though it does'nt have any dependencies.
<h3>Most simple application</h3>
Set up the include path in your IDE and link with libspline.lib (libspline.a).
All splines consists of control points. The first thing you have to do before you create your spline is to create these points. By studying this simple
example you should understand how it works.
<div class="fragment"><pre class="fragment">#include "spline.h"

int main()
{
	Spline::ControlPoint* points = new Spline::ControlPoint[3];
	points[0].position.x = 0.0f; points[0].position.y = 0.0f; points[0].position.z = 0.0f;
	points[1].position.x = 1.0f; points[1].position.y = 2.0f; points[1].position.z = 0.0f;
	points[2].position.x = 2.0f; points[2].position.y = 0.0f; points[2].position.z = 0.0f;

	Spline::CatmullRom curve(points, 3);

	delete[] points;

	return 0;
}
</pre></div>

<h2>Simple wrapper</h2>
<p>If you use multiple connected curves, you might want to know when you have traveled outside one so you can continue on the next. A wrapper around
the curve class will be handy in this situation like this splinewrapper class.
The SplineWrapper class consists of a spline and a position. The position is the distance on the spline. 0 means that you are at the begin of the curve.
To use the class you simply have to call the move function with a distance as argument. When you have traveled outside the spline the isEnd/BeginReached()
functions will return true, so you know that you should change curve.</p>

<div class="fragment"><pre class="fragment">// splinewrapper.h

#ifndef __SPLINEWRAPPER_H__
#define __SPLINEWRAPPER_H__

#include "spline.h"

struct Position {float x, y, z; };
enum CurveType {CATMULLROM, BEZIER, KOCHANEKBARTELS, CARDINAL};

class SplineWrapper
{
public:
	inline SplineWrapper(Spline::ControlPoint* controlPoints,
	                     unsigned int amount, CurveType type);
	inline ~SplineWrapper();

	inline bool     isBeginReached() const;
	inline bool     isEndReached()   const;
	inline Position getPosition()    const;
	inline void     move(float p);
	inline float    getLength()      const;

private:
	float mPosition;

	Spline::Curve* mCurve;
};

// -----------------------------------------------------------------------------
inline SplineWrapper::SplineWrapper(Spline::ControlPoint* controlPoints,
				    unsigned int amount, CurveType type)
	: mPosition(0)
{
	switch(type)
	{
	case CATMULLROM:
		mCurve = new Spline::CatmullRom(controlPoints, amount);
		break;
	case BEZIER:
		mCurve = new Spline::Bezier(controlPoints, amount);
		break;
	case KOCHANEKBARTELS:
		mCurve = new Spline::KochanekBartels(controlPoints, amount, 0, 0, 2.0f);
		break;
	case CARDINAL:
		mCurve = new Spline::Cardinal(controlPoints, amount, 1.0f);
		break;
	}
}

// -----------------------------------------------------------------------------
inline SplineWrapper::~SplineWrapper()
{
	delete mCurve;
}

// -----------------------------------------------------------------------------
inline bool SplineWrapper::isBeginReached() const
{
	return (mPosition <= 0);
}

// -----------------------------------------------------------------------------
inline bool SplineWrapper::isEndReached() const
{
	return (mPosition >= mCurve->getLength());
}

// -----------------------------------------------------------------------------
inline void SplineWrapper::move(float p)
{
	mPosition += p;

	if(mPosition > mCurve->getLength())
		mPosition = mCurve->getLength();
	else if(mPosition < 0)
		mPosition = 0;
}

// -----------------------------------------------------------------------------
inline Position SplineWrapper::getPosition() const
{
	float p[3];

	mCurve->getWorldPosition(p, mPosition);

	Position position;
	position.x = p[0];
	position.y = p[1];
	position.z = p[2];

	return position;
}

// -----------------------------------------------------------------------------
inline float SplineWrapper::getLength() const
{
	return mCurve->getLength();
}

#endif
</pre></div>
Example program that uses the SplineWrapper.
<div class="fragment"><pre class="fragment">// main.cpp
#include "splinewrapper.h"
#include <iostream>

int main()
{
	// Creates all control points to create the curve of
	Spline::ControlPoint* points = new Spline::ControlPoint[3];
	points[0].position.x = 0.0f; points[0].position.y = 0.0f; points[0].position.z = 0.0f;
	points[1].position.x = 1.0f; points[1].position.y = 2.0f; points[1].position.z = 0.0f;
	points[2].position.x = 2.0f; points[2].position.y = 0.0f; points[2].position.z = 0.0f;

	// Creates the curve. First argument is a pointer to the control points.
	// Second argument is the number of control points. The third is the curve type.
	SplineWrapper* curve = new SplineWrapper(points, 3, CATMULLROM);

	// Writes the total length of the curve to the console window
	std::cout << "Length of curve: " << curve->getLength() << std::endl;

	// The SplineWrapper has a position which is a value between 0 and the total length
	// of the curve. With the move(...) function you can increase or decrease this value
	// to move on the curve. The getPosition() function returns the world position
	// depending on how far you have moved on the curve.
	while(!curve->isEndReached())
	{
		// Travel 0.5 units on the curve each iteration
		curve->move(0.5f);
		// Get the world position
		Position p = curve->getPosition();
		std::cout << "Position: " << p.x << ", " << p.y << ", " << p.z << std::endl;
	}

	delete[] points;
	delete curve;

	return 0;
}
</pre></div>
<h2>Author</h2>
libspline is written by Joachim Klahr.
<h3 align="center">0.1.0 </h3><hr size="1"><address style="align: right;"><small>Generated on Sun Jun 11 21:10:55 2006 for libspline by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO </small></address>
</body>
</html>
